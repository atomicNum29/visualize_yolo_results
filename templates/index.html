<!doctype html>
<meta charset="utf-8">
<title>Video + YOLO Boxes Viewer</title>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
  }

  .wrap {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 12px;
    padding: 12px;
  }

  .player {
    position: relative;
    width: 100%;
  }

  video {
    /* width: 1640px; */
    max-height: 78vh;
    background: #00000000;
    object-fit: contain;
  }

  canvas {
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;
  }

  .panel {
    border: 1px solid #ddd;
    padding: 12px;
  }

  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    margin: 8px 0;
  }

  button {
    padding: 8px 12px;
  }

  select {
    padding: 6px 10px;
  }

  #timeline {
    width: 100%;
    height: 60px;
    border: 1px solid #ddd;
  }

  pre {
    white-space: pre-wrap;
    font-size: 12px;
  }

  #seek {
    height: 18px;
  }

  #time {
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    min-width: 120px;
    text-align: right;
  }
</style>

<div class="wrap">
  <div>
    <div class="row">
      <label>Video:</label>
      <select id="sel"></select>
      <button id="reload">Reload list</button>
      <label style="margin-left:12px;"><input type="checkbox" id="overlay" checked> Overlay</label>
    </div>

    <div class="player" id="player">
      <video id="v" preload="metadata" playsinline></video>
      <canvas id="c"></canvas>
    </div>

    <div class="row">
      <button id="prevHit">Prev hit</button>
      <button id="nextHit">Next hit</button>
      <button id="prevF">-1 frame</button>
      <button id="nextF">+1 frame</button>

      <button id="playPause">Play</button>
      <input id="seek" type="range" min="0" max="0" step="0.001" value="0" style="flex:1; min-width:220px;">
      <span id="time">0.000 / 0.000</span>

      <span id="info"></span>
    </div>

    <div class="row">
      <div style="flex:1;">
        <div style="font-size:12px; margin-bottom:4px;">Timeline (click to seek)</div>
        <canvas style="position: relative;" id="timeline"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3 style="margin-top:0;">Current boxes</h3>
    <pre id="boxes">-</pre>
  </div>
</div>

<script>
  const FPS = Number('{{ FPS }}');

  const sel = document.getElementById('sel');
  const v = document.getElementById('v');
  const player = document.getElementById('player');
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const overlayToggle = document.getElementById('overlay');
  const boxesPre = document.getElementById('boxes');
  const info = document.getElementById('info');

  const playPauseBtn = document.getElementById('playPause');
  const seek = document.getElementById('seek');
  const timeLbl = document.getElementById('time');
  let isSeeking = false;

  const tl = document.getElementById('timeline');
  const tlx = tl.getContext('2d');

  let currentVideo = null;
  let lastFrame = -1;
  let timeline = null; // Uint16Array-ish (counts per bin)
  let binSec = 1;
  const BOX_CHUNK_FRAMES = Math.max(30, Math.round(FPS * 2)); // batch size for box prefetch
  let boxesCache = new Map();
  let inflightBoxes = null;

  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

  function resizeCanvasToVideo() {
    // video 렌더 크기(표시 크기)에 맞춤
    const rect = v.getBoundingClientRect();
    c.width = Math.floor(rect.width);
    c.height = Math.floor(rect.height);
    c.style.width = rect.width + 'px';
    c.style.height = rect.height + 'px';
  }

  function resizeTimeline() {
    const rect = tl.getBoundingClientRect();
    // timeline 캔버스 크기 설정, width 는 video 표시 크기에 맞춤
    tl.width = Math.floor(v.getBoundingClientRect().width);
    tl.style.width = tl.width + 'px';
    tl.height = Math.floor(rect.height);
  }

  async function loadVideos() {
    const r = await fetch('/api/videos');
    const list = await r.json();
    sel.innerHTML = '';
    for (const it of list) {
      const opt = document.createElement('option');
      opt.value = it.video_id;
      opt.textContent = it.video_id;
      opt.dataset.url = it.url;
      sel.appendChild(opt);
    }
    if (list.length) {
      sel.value = list[0].video_id;
      await selectVideo(sel.value);
    }
  }

  async function selectVideo(video_id) {
    currentVideo = video_id;
    lastFrame = -1;
    boxesPre.textContent = '-';
    info.textContent = '';
    clearBoxesCache();

    const url = sel.selectedOptions[0].dataset.url;
    v.src = url;
    v.load();

    // 커스텀 컨트롤 초기화
    playPauseBtn.textContent = 'Play';
    seek.value = '0';
    seek.max = '0';
    timeLbl.textContent = '0.000 / 0.000';

    // timeline 로드(1초 bin)
    const tr = await fetch(`/api/videos/${video_id}/timeline?bin_sec=${binSec}`);
    const tj = await tr.json();
    timeline = tj.counts;
    drawTimeline();

    // 재생 준비 후 캔버스 리사이즈
    v.onloadedmetadata = () => {
      resizeCanvasToVideo();
      resizeTimeline();
      drawTimeline();
      // prefetch first chunk to avoid initial draw delay
      schedulePrefetch(0);
      // duration 기반 seek bar 설정
      if (Number.isFinite(v.duration)) {
        seek.max = String(Math.max(0, v.duration));
        timeLbl.textContent = `${v.currentTime.toFixed(3)} / ${v.duration.toFixed(3)}`;
      }
    };
  }

  function drawBoxes(boxes) {
    ctx.clearRect(0, 0, c.width, c.height);
    if (!overlayToggle.checked) return;
    if (!boxes || boxes.length === 0) return;

    // 원본 픽셀 좌표 -> 현재 표시 크기로 스케일
    const vw = v.videoWidth;
    const vh = v.videoHeight;
    if (!vw || !vh) return;
    const sx = c.width / vw;
    const sy = c.height / vh;

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'red';
    for (const b of boxes) {
      const w = b.width * sx;
      const h = b.height * sy;
      const x = b.x * sx - w / 2;
      const y = b.y * sy - h / 2;
      ctx.strokeRect(x, y, w, h);
    }
  }

  function clearBoxesCache() {
    boxesCache = new Map();
    inflightBoxes = null;
  }

  async function fetchBoxesRange(start, end) {
    if (!currentVideo) return {};
    const r = await fetch(`/api/videos/${currentVideo}/boxes_range?start_frame=${start}&end_frame=${end}`);
    if (!r.ok) return {};
    const j = await r.json();
    for (const [k, v] of Object.entries(j.boxes || {})) {
      boxesCache.set(Number(k), v);
    }
    return j.boxes || {};
  }

  function schedulePrefetch(frame) {
    const start = Math.max(0, frame - Math.floor(BOX_CHUNK_FRAMES / 3));
    const end = start + BOX_CHUNK_FRAMES - 1;
    if (inflightBoxes && frame >= inflightBoxes.start && frame <= inflightBoxes.end) {
      return inflightBoxes.promise;
    }
    const promise = fetchBoxesRange(start, end).finally(() => {
      if (inflightBoxes && inflightBoxes.promise === promise) inflightBoxes = null;
    });
    inflightBoxes = { start, end, promise };
    return promise;
  }

  async function getBoxesForFrame(frame) {
    const cached = boxesCache.get(frame);
    if (cached) return cached;
    await schedulePrefetch(frame);
    return boxesCache.get(frame) || [];
  }

  function currentFrame() {
    // 고정 FPS 가정
    return Math.max(0, Math.round(v.currentTime * FPS));
  }

  async function tick() {
    if (v.readyState >= 2 && currentVideo) {
      const f = currentFrame();
      if (f !== lastFrame) {
        lastFrame = f;
        const cached = boxesCache.get(f);
        if (cached) {
          boxesPre.textContent = JSON.stringify(cached, null, 2);
          drawBoxes(cached);
        } else {
          // draw nothing while fetching new chunk; fire prefetch in background
          drawBoxes([]);
          schedulePrefetch(f).then(() => {
            const bx = boxesCache.get(currentFrame());
            if (bx && currentVideo) {
              boxesPre.textContent = JSON.stringify(bx, null, 2);
              drawBoxes(bx);
            }
          });
        }
        info.textContent = `t=${v.currentTime.toFixed(3)}s, frame=${f}`;
      }
    }
    requestAnimationFrame(tick);
  }

  function drawTimeline() {
    if (!timeline) return;
    if (!tl.width) resizeTimeline();

    const W = tl.width, H = tl.height;
    tlx.clearRect(0, 0, W, H);

    const n = timeline.length;
    if (n === 0) return;

    // 간단히: count>0 이면 막대 높이를 올림(정규화)
    let maxv = 1;
    for (let i = 0; i < n; i++) maxv = Math.max(maxv, timeline[i]);

    for (let i = 0; i < n; i++) {
      const x0 = Math.floor(i * W / n);
      const x1 = Math.floor((i + 1) * W / n);
      const v = timeline[i];
      if (v <= 0) continue;
      const h = Math.floor((v / maxv) * (H - 2));
      tlx.fillRect(x0, H - h, Math.max(1, x1 - x0), h);
    }
  }

  function updatePlayPauseLabel() {
    playPauseBtn.textContent = v.paused ? 'Play' : 'Pause';
  }

  function updateTimeUI() {
    if (!isSeeking && Number.isFinite(v.currentTime)) {
      seek.value = String(v.currentTime);
    }
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${v.currentTime.toFixed(3)} / ${dur.toFixed(3)}`;
  }

  playPauseBtn.addEventListener('click', async () => {
    if (v.paused) {
      try { await v.play(); } catch (e) { /* autoplay 정책 등 */ }
    } else {
      v.pause();
    }
    updatePlayPauseLabel();
  });

  // 비디오 화면 클릭으로 재생/정지 토글
  v.addEventListener('click', async () => {
    if (v.paused) {
      try { await v.play(); } catch (e) { /* ignore */ }
    } else {
      v.pause();
    }
    updatePlayPauseLabel();
  });

  v.addEventListener('play', updatePlayPauseLabel);
  v.addEventListener('pause', updatePlayPauseLabel);
  v.addEventListener('timeupdate', updateTimeUI);
  v.addEventListener('durationchange', () => {
    if (Number.isFinite(v.duration)) seek.max = String(Math.max(0, v.duration));
    updateTimeUI();
  });

  // seek bar 드래그 중에는 서버 요청(박스 fetch)과 UI 갱신이 흔들리지 않게 표시만 갱신
  seek.addEventListener('input', () => {
    isSeeking = true;
    const t = Number(seek.value);
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${t.toFixed(3)} / ${dur.toFixed(3)}`;
  });

  seek.addEventListener('change', () => {
    const t = Number(seek.value);
    v.currentTime = clamp(t, 0, Math.max(0, (Number.isFinite(v.duration) ? v.duration : 0) - 0.001));
    isSeeking = false;
    // 즉시 반영되도록
    lastFrame = -1;
  });

  // 키보드 단축키 (Space: 재생/정지, ←/→: 프레임 이동, N/P: next/prev hit)
  window.addEventListener('keydown', async (e) => {
    // 입력창/슬라이더 조작 중이면 방해하지 않음
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'select' || tag === 'textarea') return;

    if (e.code === 'Space') {
      e.preventDefault();
      if (v.paused) { try { await v.play(); } catch (err) { } } else { v.pause(); }
      updatePlayPauseLabel();
    } else if (e.code === 'ArrowLeft') {
      e.preventDefault();
      moveFrame(-1);
      lastFrame = -1;
    } else if (e.code === 'ArrowRight') {
      e.preventDefault();
      moveFrame(1);
      lastFrame = -1;
    } else if (e.key === 'n' || e.key === 'N') {
      e.preventDefault();
      jumpHit('next');
    } else if (e.key === 'p' || e.key === 'P') {
      e.preventDefault();
      jumpHit('prev');
    }
  });

  tl.addEventListener('click', (e) => {
    if (!timeline || !currentVideo || !v.duration) return;
    const rect = tl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const n = timeline.length;
    const idx = clamp(Math.floor(x * n / rect.width), 0, n - 1);
    const t = idx * binSec;
    v.currentTime = clamp(t, 0, Math.max(0, v.duration - 0.01));
  });

  document.getElementById('reload').onclick = loadVideos;
  sel.onchange = async () => selectVideo(sel.value);

  async function moveFrame(delta) {
    if (!currentVideo) return;
    v.currentTime = (currentFrame() + delta) / FPS + 0.0001; // 약간 오프셋 줘서 프레임 계산 오류 방지
  }

  document.getElementById('prevF').onclick = () => {
    moveFrame(-1);
  };
  document.getElementById('nextF').onclick = () => {
    moveFrame(1);
  };

  async function jumpHit(dir) {
    if (!currentVideo) return;
    const f = currentFrame();
    const r = await fetch(`/api/videos/${currentVideo}/${dir}_hit?frame=${f}`);
    if (!r.ok) return;
    const j = await r.json();
    if (j && j.frame != null) {
      v.currentTime = j.frame / FPS + 0.0001; // 약간 오프셋 줘서 프레임 계산 오류 방지
    }
  }
  document.getElementById('prevHit').onclick = () => jumpHit('prev');
  document.getElementById('nextHit').onclick = () => jumpHit('next');

  window.addEventListener('resize', () => {
    resizeCanvasToVideo();
    resizeTimeline();
    drawTimeline();
    updateTimeUI();
  });

  loadVideos();
  tick();
</script>