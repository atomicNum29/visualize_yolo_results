<!doctype html>
<meta charset="utf-8">
<title>Video + YOLO Boxes Viewer</title>

<head>
  <base href="/videoviewer/">
</head>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
  }

  .wrap {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 12px;
    padding: 12px;
  }

  .player {
    position: relative;
    width: 100%;
  }

  video {
    max-height: 78vh;
    background: #00000000;
    object-fit: contain;
  }

  canvas {
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;
  }

  .panel {
    border: 1px solid #ddd;
    padding: 12px;
  }

  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    margin: 8px 0;
  }

  button {
    padding: 8px 12px;
  }

  select {
    padding: 6px 10px;
  }

  #timeline {
    width: 100%;
    height: 60px;
    border: 1px solid #ddd;
  }

  pre {
    white-space: pre-wrap;
    font-size: 12px;
  }

  #seek {
    height: 18px;
  }

  #time {
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    min-width: 120px;
    text-align: right;
  }

  /* Ïπ¥Ïö¥ÌÑ∞ Ïä§ÌÉÄÏùº */
  .counter-box {
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
  }

  .counter-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: bold;
  }

  .counter-controls button {
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
  }

  .log-preview {
    max-height: 150px;
    overflow-y: auto;
    background: #f9f9f9;
    border: 1px solid #eee;
    padding: 4px;
    font-size: 11px;
    margin-top: 8px;
  }

  .download-btn {
    width: 100%;
    margin-top: 8px;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
  }

  .download-btn:hover {
    background-color: #45a049;
  }

  .clear-btn { flex: 1; background-color: #f44336; color: white; border: none; }
  .clear-btn:hover { background-color: #d32f2f; }

  /* ÏôÑÎ£å ÏÉÅÌÉú Î≤ÑÌäº Ïä§ÌÉÄÏùº */
  #toggleCompleteBtn {
    font-weight: bold;
    border: 1px solid #ccc;
    border-radius: 4px;
    transition: all 0.2s;
  }
  /* ÎØ∏ÏôÑÎ£å ÏÉÅÌÉú (Í∏∞Î≥∏) */
  #toggleCompleteBtn.incomplete {
    background-color: #f0f0f0;
    color: #555;
  }
  #toggleCompleteBtn.incomplete:hover {
    background-color: #e0e0e0;
  }
  /* ÏôÑÎ£å ÏÉÅÌÉú */
  #toggleCompleteBtn.completed {
    background-color: #4CAF50; /* Green */
    color: white;
    border-color: #45a049;
  }
  #toggleCompleteBtn.completed:hover {
    background-color: #45a049;
  }

  /* Ï†ÄÏû• ÏÉÅÌÉú ÌëúÏãú */
  #syncStatus {
    font-size: 11px;
    margin-left: auto;
    color: #888;
  }
</style>

<div class="wrap">
  <div>
    <div class="row">
      <label>Video:</label>
      <select id="sel"></select>
      <button id="reload">Reload list</button>
      
      <div style="display:inline-flex; gap:5px; margin-left:10px;">
        <button id="toggleProgressBtn" class="incomplete" onclick="toggleProgress()">In Progress</button>
        <button id="toggleCompleteBtn" class="incomplete" onclick="toggleCompletion()">Completed</button>
      </div>
      
      <label style="margin-left:12px;"><input type="checkbox" id="overlay" checked> Overlay</label>
    </div>

    <div class="player" id="player">
      <video id="v" preload="metadata" playsinline></video>
      <canvas id="c"></canvas>
    </div>

    <div class="row">
      <button id="prevHit">Prev hit</button>
      <button id="nextHit">Next hit</button>
      
      <button id="prevF" style="margin-left:auto;">-1 frame</button>
      <button id="nextF">+1 frame</button>

      <button id="playPause">Play</button>
      <label style="display:flex; align-items:center; gap:4px;">
        Speed
        <select id="speed">
          <option value="0.25">0.25x</option>
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </label>
      <input id="seek" type="range" min="0" max="0" step="0.001" value="0" style="flex:1; min-width:220px;">
      <span id="time">00:00:00 / 00:00:00</span>
      <span id="info"></span>
    </div>

    <div class="row">
      <div style="flex:1;">
        <div style="font-size:12px; margin-bottom:4px;">Timeline (click to seek)</div>
        <canvas style="position: relative;" id="timeline"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="counter-box">
      <div style="display:flex; align-items:center;">
        <h3 style="margin-top:0; margin-bottom:0;">Server Log</h3>
        <span id="syncStatus">Synced</span>
      </div>
      <div style="font-size:11px; color:#666; margin-bottom:10px; margin-top:5px;">
        * Data is saved to server (shared).
      </div>

      <div class="counter-row">
        <span style="color: blue;">IN (Key: I)</span>
        <span id="displayIn">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('in', 1)">+</button>
          <button onclick="manualAdjust('in', -1)">-</button>
        </div>
      </div>
      <div class="counter-row">
        <span style="color: red;">OUT (Key: O)</span>
        <span id="displayOut">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('out', 1)">+</button>
          <button onclick="manualAdjust('out', -1)">-</button>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="download-btn" onclick="downloadCSV()">Download Log</button>
        <button class="clear-btn" onclick="clearCurrentVideoLog()">Clear Log</button>
      </div>
      
      <div style="font-size: 12px; margin-top: 8px; font-weight: bold;">Current Video Logs:</div>
      <div id="logPreview" class="log-preview"></div>
    </div>

    <h3 style="margin-top:10px;">Current boxes</h3>
    <pre id="boxes">-</pre>
  </div>
</div>

<script>
  const FPS = Number('{{ FPS }}');

  // --- HTML Elements ---
  const sel = document.getElementById('sel');
  const v = document.getElementById('v');
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const overlayToggle = document.getElementById('overlay');
  const boxesPre = document.getElementById('boxes');
  const info = document.getElementById('info');
  const playPauseBtn = document.getElementById('playPause');
  const seek = document.getElementById('seek');
  const timeLbl = document.getElementById('time');
  const speedSelect = document.getElementById('speed');
  const tl = document.getElementById('timeline');
  const tlx = tl.getContext('2d');
  const toggleCompleteBtn = document.getElementById('toggleCompleteBtn');
  const toggleProgressBtn = document.getElementById('toggleProgressBtn');
  const syncStatus = document.getElementById('syncStatus');

  const displayIn = document.getElementById('displayIn');
  const displayOut = document.getElementById('displayOut');
  const logPreview = document.getElementById('logPreview');

  // --- Global State ---
  let isSeeking = false;
  let currentVideo = null;
  let videoList = []; 
  let lastFrame = -1;
  let timeline = null; 
  let binSec = 1;
  const BOX_CHUNK_FRAMES = Math.max(300, Math.round(FPS * 10)); 
  let boxesCache = new Map();
  let inflightBoxes = null;
  let currentSpeed = parseFloat(speedSelect.value) || 1;

  // --- State Variables ---
  let countIn = 0;
  let countOut = 0;
  let isCompleted = false;
  let isInProgress = false;
  let eventLogs = [];

  // --- Utility Functions ---
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function formatTime(seconds) {
    if (!Number.isFinite(seconds)) return "00:00:00";
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
  }

  // --- ÎìúÎ°≠Îã§Ïö¥ Î†åÎçîÎßÅ ---
  function renderVideoDropdown() {
    const currentSelection = sel.value;
    sel.innerHTML = '';
    
    for (const it of videoList) {
      const opt = document.createElement('option');
      opt.value = it.video_id;
      
      let prefix = "";
      if (it.status === 'completed') {
        prefix = "‚úÖ ";
      } else if (it.status === 'in_progress') {
        prefix = "üöß ";
      }
      
      opt.textContent = `${prefix}${it.video_id}`; 
      opt.dataset.url = it.url;
      opt.dataset.status = it.status; 
      
      sel.appendChild(opt);
    }
    
    if (currentSelection) sel.value = currentSelection;
  }

  function updateDropdownCurrentText() {
    const opt = sel.options[sel.selectedIndex];
    if (!opt) return;

    // ÌòÑÏû¨ ÏÉÅÌÉú Í≥ÑÏÇ∞ (ÌïòÎÇòÎßå ÌôúÏÑ±ÌôîÎê®)
    let status = "new";
    let prefix = "";

    if (isCompleted) {
      status = "completed";
      prefix = "‚úÖ ";
    } else if (isInProgress) {
      status = "in_progress";
      prefix = "üöß ";
    }

    opt.textContent = `${prefix}${currentVideo}`;
    opt.dataset.status = status;
    
    const vidItem = videoList.find(v => v.video_id === currentVideo);
    if (vidItem) {
      vidItem.status = status;
    }
  }

  // --- Server Communication ---
  async function fetchLogFromServer(video_id) {
    try {
      const r = await fetch(`api/logs/${video_id}`);
      if (r.ok) {
        const data = await r.json();
        countIn = data.in;
        countOut = data.out;
        isCompleted = data.is_completed;
        isInProgress = data.is_in_progress || false; 
        eventLogs = data.logs;
      } else {
        countIn = 0; countOut = 0; isCompleted = false; isInProgress = false; eventLogs = [];
      }
    } catch (e) {
      console.error("Network error loading log", e);
    }
  }

  async function saveLogToServer() {
    if (!currentVideo) return;
    
    syncStatus.textContent = "Saving...";
    syncStatus.style.color = "orange";

    const payload = {
      in_count: countIn,
      out_count: countOut,
      is_completed: isCompleted,
      is_in_progress: isInProgress,
      logs: eventLogs
    };

    try {
      const r = await fetch(`api/logs/${currentVideo}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (r.ok) {
        syncStatus.textContent = "Saved";
        syncStatus.style.color = "green";
        updateDropdownCurrentText();
      } else {
        syncStatus.textContent = "Error!";
        syncStatus.style.color = "red";
      }
    } catch (e) {
      console.error("Save failed", e);
      syncStatus.textContent = "Offline?";
      syncStatus.style.color = "red";
    }
  }

  // --- Status Toggle Logic (ÏÉÅÌò∏ Î∞∞Ï†ú Ï†ÅÏö©) ---

  // 1. ÏûëÏóÖ Ï§ë Î≤ÑÌäº ÌÜ†Í∏Ä
  window.toggleProgress = function() {
    if (!currentVideo) return;

    // Ïù¥ÎØ∏ ÏºúÏ†∏ÏûàÏúºÎ©¥ -> ÎÅî (New ÏÉÅÌÉú)
    if (isInProgress) {
      isInProgress = false;
    } else {
      // Í∫ºÏ†∏ÏûàÏúºÎ©¥ -> Ïº¨ & ÏôÑÎ£åÎäî ÎÅî (ÏÉÅÌò∏ Î∞∞Ï†ú)
      isInProgress = true;
      isCompleted = false;
    }

    updateStatusUI();
    saveLogToServer();
  };

  // 2. ÏôÑÎ£å Î≤ÑÌäº ÌÜ†Í∏Ä
  window.toggleCompletion = function() {
    if (!currentVideo) return;

    // Ïù¥ÎØ∏ ÏôÑÎ£åÎ©¥ -> ÎÅî (New ÏÉÅÌÉú)
    if (isCompleted) {
      isCompleted = false;
    } else {
      // ÏºúÍ∏∞ -> ÏûëÏóÖ Ï§ëÏùÄ Î¨¥Ï°∞Í±¥ ÎÅî (ÏÉÅÌò∏ Î∞∞Ï†ú)
      isCompleted = true;
      isInProgress = false;
    }
    
    updateStatusUI();
    saveLogToServer();
  };
  
  // Î≤ÑÌäº Ïä§ÌÉÄÏùº ÏóÖÎç∞Ïù¥Ìä∏
  function updateStatusUI() {
    // 1. Completed Button State
    if (isCompleted) {
      toggleCompleteBtn.textContent = "Completed ‚úÖ";
      toggleCompleteBtn.style.backgroundColor = "#4CAF50"; // Green
      toggleCompleteBtn.style.color = "white";
      toggleCompleteBtn.style.borderColor = "#45a049";
    } else {
      toggleCompleteBtn.textContent = "Mark as Completed";
      toggleCompleteBtn.style.backgroundColor = "#f0f0f0"; // Gray
      toggleCompleteBtn.style.color = "#555";
      toggleCompleteBtn.style.borderColor = "#ccc";
    }

    // 2. In Progress Button State
    if (isInProgress) {
      toggleProgressBtn.textContent = "In Progress üöß";
      toggleProgressBtn.style.backgroundColor = "#ff9800"; // Orange
      toggleProgressBtn.style.color = "white";
      toggleProgressBtn.style.borderColor = "#e68900";
    } else {
      toggleProgressBtn.textContent = "Mark In Progress";
      toggleProgressBtn.style.backgroundColor = "#f0f0f0"; // Gray
      toggleProgressBtn.style.color = "#555";
      toggleProgressBtn.style.borderColor = "#ccc";
    }

    // ÎìúÎ°≠Îã§Ïö¥ ÌÖçÏä§Ìä∏ÎèÑ Í∞±Ïã†
    updateDropdownCurrentText();
  }

  // --- Canvas & Video Resizing ---
  function resizeCanvasToVideo() {
    const rect = v.getBoundingClientRect();
    c.width = Math.floor(rect.width);
    c.height = Math.floor(rect.height);
    c.style.width = rect.width + 'px';
    c.style.height = rect.height + 'px';
  }
  function resizeTimeline() {
    const rect = tl.getBoundingClientRect();
    tl.width = Math.floor(v.getBoundingClientRect().width);
    tl.style.width = tl.width + 'px';
    tl.height = Math.floor(rect.height);
  }
  function setPlaybackRate(rate) {
    const r = Number.isFinite(rate) ? rate : 1;
    currentSpeed = r;
    v.playbackRate = r;
    speedSelect.value = String(r);
  }

  // --- Data Loading ---
  async function loadVideos() {
    const r = await fetch('api/videos');
    videoList = await r.json(); // Ï†ÑÏó≠ Î≥ÄÏàòÏóê Ï†ÄÏû•
    
    renderVideoDropdown(); // ÎìúÎ°≠Îã§Ïö¥ Í∑∏Î¶¨Í∏∞ Î∂ÑÎ¶¨

    if (videoList.length) {
      // Ïù¥Ï†ÑÏóê ÏÑ†ÌÉùÌñàÎçò ÎπÑÎîîÏò§Í∞Ä ÏûàÏúºÎ©¥ Ïú†ÏßÄ, ÏóÜÏúºÎ©¥ Ï≤´ Î≤àÏß∏
      if (!currentVideo) currentVideo = videoList[0].video_id;
      // ÏÖÄÎ†âÌä∏ Î∞ïÏä§ Í∞í ÎèôÍ∏∞Ìôî
      sel.value = currentVideo;
      await selectVideo(sel.value);
    }
  }

  async function selectVideo(video_id) {
    currentVideo = video_id;
    lastFrame = -1;
    boxesPre.textContent = '-';
    info.textContent = '';
    clearBoxesCache();
  
    await fetchLogFromServer(video_id);
    
    updateCounterUI();
    renderLogs();
    updateStatusUI();

    // ÏÑ†ÌÉùÎêú ÏòµÏÖòÏùò URL Ï∞æÍ∏∞
    const selectedOption = Array.from(sel.options).find(opt => opt.value === video_id);
    if (!selectedOption) return; // Î∞©Ïñ¥ ÏΩîÎìú

    let url = selectedOption.dataset.url;

    // [ÌïµÏã¨] ÎßåÏïΩ URLÏù¥ /Î°ú ÏãúÏûëÌïòÎ©¥, base ÌÉúÍ∑∏Í∞Ä Î¨¥ÏãúÎêòÏñ¥ Î£®Ìä∏(/)Î°ú Í∞ÄÎ≤ÑÎ¶ΩÎãàÎã§.
    // ÌòÑÏû¨ ÏÑúÎ≤ÑÍ∞Ä Î£®Ìä∏(/videos) ÏöîÏ≤≠ÏùÑ Í±∞Î∂ÄÌïòÍ≥† ÏûàÏúºÎØÄÎ°ú, 
    // ÏïûÏùò Ïä¨ÎûòÏãúÎ•º Ï†úÍ±∞Ìï¥ base ÌÉúÍ∑∏(/videoviewer/)Í∞Ä Ï†ÅÏö©ÎêòÎèÑÎ°ù Í∞ïÏ†úÌï©ÎãàÎã§.
    if (url.startsWith('/')) {
        url = url.substring(1); 
    }

    v.src = url;
    v.load();
    setPlaybackRate(currentSpeed);

    playPauseBtn.textContent = 'Play';
    seek.value = '0';
    seek.max = '0';
    timeLbl.textContent = '00:00:00 / 00:00:00';

    const tr = await fetch(`api/videos/${video_id}/timeline?bin_sec=${binSec}`);
    const tj = await tr.json();
    timeline = tj.counts;
    drawTimeline();

    v.onloadedmetadata = () => {
      resizeCanvasToVideo();
      resizeTimeline();
      drawTimeline();
      schedulePrefetch(0);
      if (Number.isFinite(v.duration)) {
        seek.max = String(Math.max(0, v.duration));
        timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(v.duration)}`;
      }
    };
  }

  // --- Box Fetching ---
  function clearBoxesCache() {
    boxesCache = new Map();
    inflightBoxes = null;
  }
  async function fetchBoxesRange(start, end) {
    if (!currentVideo) return {};
    const r = await fetch(`api/videos/${currentVideo}/boxes_range?start_frame=${start}&end_frame=${end}`);
    if (!r.ok) return {};
    const j = await r.json();
    for (const [k, v] of Object.entries(j.boxes || {})) {
      boxesCache.set(Number(k), v);
    }
    return j.boxes || {};
  }
  function schedulePrefetch(frame) {
    const start = Math.max(0, frame - Math.floor(BOX_CHUNK_FRAMES / 3));
    const end = start + BOX_CHUNK_FRAMES - 1;
    if (inflightBoxes && frame >= inflightBoxes.start && frame <= inflightBoxes.end) {
      return inflightBoxes.promise;
    }
    const promise = fetchBoxesRange(start, end).finally(() => {
      if (inflightBoxes && inflightBoxes.promise === promise) inflightBoxes = null;
    });
    inflightBoxes = { start, end, promise };
    return promise;
  }

  async function getBoxesForFrame(frame) {
    const cached = boxesCache.get(frame);
    if (cached) return cached;
    await schedulePrefetch(frame);
    return boxesCache.get(frame) || [];
  }

  // --- Render Loop ---
  function currentFrame() {
    return Math.max(0, Math.round(v.currentTime * FPS));
  }

  function drawBoxes(boxes) {
    ctx.clearRect(0, 0, c.width, c.height);
    if (!overlayToggle.checked) return;
    if (!boxes || boxes.length === 0) return;

    const vw = v.videoWidth;
    const vh = v.videoHeight;
    if (!vw || !vh) return;
    const sx = c.width / vw;
    const sy = c.height / vh;

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'red';
    for (const b of boxes) {
      const w = b.width * sx;
      const h = b.height * sy;
      const x = b.x * sx - w / 2;
      const y = b.y * sy - h / 2;
      ctx.strokeRect(x, y, w, h);
    }

    boxesPre.textContent = `Count: ${boxes.length}\n` + JSON.stringify(boxes, null, 2);
  }

  async function tick() {
    if (v.readyState >= 2 && currentVideo) {
      const f = currentFrame();
      if (f !== lastFrame) {
        lastFrame = f;
        const cached = boxesCache.get(f);
        const boxes = cached || [];
        if (!cached) schedulePrefetch(f);

        drawBoxes(boxes);
        info.textContent = `t=${formatTime(v.currentTime)}, frame=${f}`;
      }
    }
    requestAnimationFrame(tick);
  }

  // --- Timeline Drawing ---
  function drawTimeline() {
    if (!timeline) return;
    if (!tl.width) resizeTimeline();
    const W = tl.width, H = tl.height;
    tlx.clearRect(0, 0, W, H);
    const n = timeline.length;
    if (n === 0) return;
    let maxv = 1;
    for (let i = 0; i < n; i++) maxv = Math.max(maxv, timeline[i]);
    for (let i = 0; i < n; i++) {
      const x0 = Math.floor(i * W / n);
      const x1 = Math.floor((i + 1) * W / n);
      const v = timeline[i];
      if (v <= 0) continue;
      const h = Math.floor((v / maxv) * (H - 2));
      tlx.fillRect(x0, H - h, Math.max(1, x1 - x0), h);
    }
  }

  // --- UI Update Helper ---
  function updatePlayPauseLabel() {
    playPauseBtn.textContent = v.paused ? 'Play' : 'Pause';
  }
  function updateTimeUI() {
    if (!isSeeking && Number.isFinite(v.currentTime)) {
      seek.value = String(v.currentTime);
    }
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(dur)}`;
  }

  // --- Counter & Log Functions ---
  function updateCounterUI() {
    if (displayIn) displayIn.textContent = countIn;
    if (displayOut) displayOut.textContent = countOut;
  }
  function renderLogs() {
    logPreview.innerHTML = '';
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      const log = eventLogs[i];
      const timeStr = formatTime(log.rawTime);
      const div = document.createElement('div');
      div.innerHTML = `<span style="color:#666">[${timeStr}]</span> ${log.type}`;
      logPreview.appendChild(div);
    }
  }
  function addLog(type) {
    eventLogs.push({ rawTime: v.currentTime, type: type });
    renderLogs();
    saveLogToServer(); 
  }
  function removeLastLog(type) {
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      if (eventLogs[i].type === type) {
        eventLogs.splice(i, 1); 
        renderLogs(); 
        saveLogToServer(); 
        return;
      }
    }
  }
  window.manualAdjust = function(type, delta) {
    if (type === 'in') {
      if (delta > 0) { countIn++; addLog('IN'); } 
      else if (countIn > 0) { countIn--; removeLastLog('IN'); }
    } else {
      if (delta > 0) { countOut++; addLog('OUT'); } 
      else if (countOut > 0) { countOut--; removeLastLog('OUT'); }
    }
    updateCounterUI();
  };
  window.clearCurrentVideoLog = function() {
    if (confirm(`'${currentVideo}'Ïùò ÏÑúÎ≤Ñ Î°úÍ∑∏Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
      countIn = 0; countOut = 0; eventLogs = []; isCompleted = false; isInProgress = false;
      updateCounterUI(); renderLogs(); updateStatusUI();
      saveLogToServer();
    }
  };
  window.downloadCSV = function() {
    if (eventLogs.length === 0) { alert("No logs for this video."); return; }
    let csv = "data:text/csv;charset=utf-8,Video ID,Video Time,Real Time,Type\n"; 
    eventLogs.forEach(row => {
      csv += `${currentVideo},${formatTime(row.rawTime)},${formatTime(row.rawTime + 28800)},${row.type}\n`;
    });
    csv += `\nSummary,,\nTotal IN,${countIn},\nTotal OUT,${countOut},\n`;
    const encodedUri = encodeURI(csv);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `log_${currentVideo}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // --- Event Listeners ---
  playPauseBtn.addEventListener('click', async () => {
    v.paused ? v.play().catch(() => { }) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('click', async () => {
    v.paused ? v.play().catch(() => { }) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('play', updatePlayPauseLabel);
  v.addEventListener('pause', updatePlayPauseLabel);
  v.addEventListener('timeupdate', updateTimeUI);
  v.addEventListener('durationchange', () => {
    if (Number.isFinite(v.duration)) seek.max = String(Math.max(0, v.duration));
    updateTimeUI();
  });
  speedSelect.addEventListener('change', () => setPlaybackRate(parseFloat(speedSelect.value)));
  seek.addEventListener('input', () => {
    isSeeking = true;
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(Number(seek.value))} / ${formatTime(dur)}`;
  });
  seek.addEventListener('change', () => {
    v.currentTime = clamp(Number(seek.value), 0, v.duration - 0.001);
    isSeeking = false; lastFrame = -1;
  });
  window.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (['input', 'select', 'textarea'].includes(tag)) return;
    if (e.code === 'Space') { e.preventDefault(); v.paused ? v.play().catch(() => { }) : v.pause(); }
    else if (e.key === ',') { e.preventDefault(); moveFrame(-1); lastFrame = -1; }
    else if (e.key === '.') { e.preventDefault(); moveFrame(1); lastFrame = -1; }
    else if (e.key.toLowerCase() === 'n') { e.preventDefault(); jumpHit('next'); }
    else if (e.key.toLowerCase() === 'b') { e.preventDefault(); jumpHit('prev'); }
    else if (e.key.toLowerCase() === 'i') { e.preventDefault(); window.manualAdjust('in', 1); updateCounterUI(); } // KeydownÏóêÏÑúÎäî addLog Ï§ëÎ≥µ Î∞©ÏßÄ (manualAdjustÍ∞Ä Ìò∏Ï∂úÌïòÎØÄÎ°ú)
    else if (e.key.toLowerCase() === 'o') { e.preventDefault(); window.manualAdjust('out', 1); updateCounterUI(); }
  });

  tl.addEventListener('click', (e) => {
    if (!timeline || !currentVideo || !v.duration) return;
    const rect = tl.getBoundingClientRect();
    const t = clamp(Math.floor((e.clientX - rect.left) * timeline.length / rect.width), 0, timeline.length - 1) * binSec;
    v.currentTime = clamp(t, 0, v.duration - 0.01);
  });
  document.getElementById('reload').onclick = loadVideos;
  sel.onchange = () => selectVideo(sel.value);
  document.getElementById('prevF').onclick = () => moveFrame(-1);
  document.getElementById('nextF').onclick = () => moveFrame(1);
  
  document.getElementById('prevHit').onclick = () => jumpHit('prev');
  document.getElementById('nextHit').onclick = () => jumpHit('next');
  window.addEventListener('resize', () => { resizeCanvasToVideo(); resizeTimeline(); drawTimeline(); updateTimeUI(); });

  async function moveFrame(delta) { if (currentVideo) v.currentTime = (currentFrame() + delta) / FPS + 0.0001; }

  async function jumpHit(dir) {
    if (!currentVideo) { console.warn("No video selected."); return; }
    const currentF = currentFrame();
    const url = `api/videos/${currentVideo}/${dir}_hit?frame=${currentF}`;
    try {
      const r = await fetch(url);
      if (!r.ok) { console.error(`[JumpHit] Server Error: ${r.status}`); return; }
      const j = await r.json();
      if (j.frame !== null && j.frame !== undefined) {
        v.currentTime = j.frame / FPS + 0.0001;
      } else {
        console.warn("[JumpHit] No more hits found.");
      }
    } catch (e) {
      console.error("[JumpHit] Network/JS Error:", e);
    }
  }

  loadVideos();
  tick();
</script>