<!doctype html>
<meta charset="utf-8">
<title>Video + YOLO Boxes Viewer</title>

<head>
  <base href="/videoviewer/">
</head>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
  }

  .wrap {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 12px;
    padding: 12px;
  }

  .player {
    position: relative;
    width: 100%;
  }

  video {
    max-height: 78vh;
    background: #00000000;
    object-fit: contain;
  }

  canvas {
    position: absolute;
    left: 0;
    top: 0;
    pointer-events: none;
  }

  .panel {
    border: 1px solid #ddd;
    padding: 12px;
  }

  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    margin: 8px 0;
  }

  button {
    padding: 8px 12px;
  }

  select {
    padding: 6px 10px;
  }

  #timeline {
    width: 100%;
    height: 60px;
    border: 1px solid #ddd;
  }

  pre {
    white-space: pre-wrap;
    font-size: 12px;
  }

  #seek {
    height: 18px;
  }

  #time {
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    min-width: 120px;
    text-align: right;
  }

  /* 카운터 스타일 */
  .counter-box {
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid #eee;
  }

  .counter-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: bold;
  }

  .counter-controls button {
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
  }

  .log-preview {
    max-height: 150px;
    overflow-y: auto;
    background: #f9f9f9;
    border: 1px solid #eee;
    padding: 4px;
    font-size: 11px;
    margin-top: 8px;
  }

  .download-btn {
    width: 100%;
    margin-top: 8px;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
  }

  .download-btn:hover {
    background-color: #45a049;
  }

  /* 스캔 상태 표시 */
  #scan-status {
    color: red;
    font-weight: bold;
    margin-left: 10px;
    display: none;
    font-size: 14px;
  }
</style>

<div class="wrap">
  <div>
    <div class="row">
      <label>Video:</label>
      <select id="sel"></select>
      <button id="reload">Reload list</button>
      <label style="margin-left:12px;"><input type="checkbox" id="overlay" checked> Overlay</label>
    </div>

    <div class="player" id="player">
      <video id="v" preload="metadata" playsinline></video>
      <canvas id="c"></canvas>
    </div>

    <div class="row">
      <button id="prevHit">Prev hit</button>
      <button id="nextHit">Next hit</button>
      <span id="scan-status">Skipping filtered...</span>

      <button id="prevF" style="margin-left:auto;">-1 frame</button>
      <button id="nextF">+1 frame</button>

      <button id="playPause">Play</button>
      <label style="display:flex; align-items:center; gap:4px;">
        Speed
        <select id="speed">
          <option value="0.25">0.25x</option>
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </label>
      <input id="seek" type="range" min="0" max="0" step="0.001" value="0" style="flex:1; min-width:220px;">
      <span id="time">00:00:00 / 00:00:00</span>
      <span id="info"></span>
    </div>

    <div class="row">
      <div style="flex:1;">
        <div style="font-size:12px; margin-bottom:4px;">Timeline (click to seek)</div>
        <canvas style="position: relative;" id="timeline"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="counter-box">
      <h3 style="margin-top:0;">Bee Counter</h3>
      <div class="counter-row">
        <span style="color: blue;">IN (Key: I)</span>
        <span id="displayIn">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('in', 1)">+</button>
          <button onclick="manualAdjust('in', -1)">-</button>
        </div>
      </div>
      <div class="counter-row">
        <span style="color: red;">OUT (Key: O)</span>
        <span id="displayOut">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('out', 1)">+</button>
          <button onclick="manualAdjust('out', -1)">-</button>
        </div>
      </div>
      <button class="download-btn" onclick="downloadCSV()">Download CSV</button>
      <div style="font-size: 12px; margin-top: 8px; font-weight: bold;">Recent Logs:</div>
      <div id="logPreview" class="log-preview"></div>
    </div>

    <h3 style="margin-top:10px;">Current boxes</h3>
    <div style="font-size:11px; color:#666; margin-bottom:4px;">
      * Server-side filtering active (Static objects removed)
    </div>
    <pre id="boxes">-</pre>
  </div>
</div>

<script>
  const FPS = Number('{{ FPS }}');

  // --- HTML Elements ---
  const sel = document.getElementById('sel');
  const v = document.getElementById('v');
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const overlayToggle = document.getElementById('overlay');
  const boxesPre = document.getElementById('boxes');
  const info = document.getElementById('info');
  const playPauseBtn = document.getElementById('playPause');
  const seek = document.getElementById('seek');
  const timeLbl = document.getElementById('time');
  const speedSelect = document.getElementById('speed');
  const tl = document.getElementById('timeline');
  const tlx = tl.getContext('2d');
  const scanStatus = document.getElementById('scan-status');

  // --- Global State ---
  let isSeeking = false;
  let currentVideo = null;
  let lastFrame = -1;
  let timeline = null;
  let binSec = 1;
  const BOX_CHUNK_FRAMES = Math.max(30, Math.round(FPS * 2));
  let boxesCache = new Map();
  let inflightBoxes = null;
  let currentSpeed = parseFloat(speedSelect.value) || 1;

  // --- Counter State ---
  let countIn = 0;
  let countOut = 0;
  let eventLogs = [];
  const displayIn = document.getElementById('displayIn');
  const displayOut = document.getElementById('displayOut');
  const logPreview = document.getElementById('logPreview');

  // --- Utility Functions ---
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function formatTime(seconds) {
    if (!Number.isFinite(seconds)) return "00:00:00";
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
  }

  // --- Canvas & Video Resizing ---
  function resizeCanvasToVideo() {
    const rect = v.getBoundingClientRect();
    c.width = Math.floor(rect.width);
    c.height = Math.floor(rect.height);
    c.style.width = rect.width + 'px';
    c.style.height = rect.height + 'px';
  }
  function resizeTimeline() {
    const rect = tl.getBoundingClientRect();
    tl.width = Math.floor(v.getBoundingClientRect().width);
    tl.style.width = tl.width + 'px';
    tl.height = Math.floor(rect.height);
  }
  function setPlaybackRate(rate) {
    const r = Number.isFinite(rate) ? rate : 1;
    currentSpeed = r;
    v.playbackRate = r;
    speedSelect.value = String(r);
  }

  // --- Data Loading ---
  async function loadVideos() {
    const r = await fetch('api/videos');
    const list = await r.json();
    sel.innerHTML = '';
    for (const it of list) {
      const opt = document.createElement('option');
      opt.value = it.video_id;
      opt.textContent = it.video_id;
      opt.dataset.url = it.url;
      sel.appendChild(opt);
    }
    if (list.length) {
      sel.value = list[0].video_id;
      await selectVideo(sel.value);
    }
  }

  async function selectVideo(video_id) {
    currentVideo = video_id;
    lastFrame = -1;
    boxesPre.textContent = '-';
    info.textContent = '';
    clearBoxesCache();
    resetCounters();

    const url = sel.selectedOptions[0].dataset.url;
    v.src = url;
    v.load();
    setPlaybackRate(currentSpeed);

    playPauseBtn.textContent = 'Play';
    seek.value = '0';
    seek.max = '0';
    timeLbl.textContent = '00:00:00 / 00:00:00';

    const tr = await fetch(`api/videos/${video_id}/timeline?bin_sec=${binSec}`);
    const tj = await tr.json();
    timeline = tj.counts;
    drawTimeline();

    v.onloadedmetadata = () => {
      resizeCanvasToVideo();
      resizeTimeline();
      drawTimeline();
      schedulePrefetch(0);
      if (Number.isFinite(v.duration)) {
        seek.max = String(Math.max(0, v.duration));
        timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(v.duration)}`;
      }
    };
  }

  // --- Box Fetching ---
  function clearBoxesCache() {
    boxesCache = new Map();
    inflightBoxes = null;
  }
  async function fetchBoxesRange(start, end) {
    if (!currentVideo) return {};
    const r = await fetch(`api/videos/${currentVideo}/boxes_range?start_frame=${start}&end_frame=${end}`);
    if (!r.ok) return {};
    const j = await r.json();
    for (const [k, v] of Object.entries(j.boxes || {})) {
      boxesCache.set(Number(k), v);
    }
    return j.boxes || {};
  }
  function schedulePrefetch(frame) {
    const start = Math.max(0, frame - Math.floor(BOX_CHUNK_FRAMES / 3));
    const end = start + BOX_CHUNK_FRAMES - 1;
    if (inflightBoxes && frame >= inflightBoxes.start && frame <= inflightBoxes.end) {
      return inflightBoxes.promise;
    }
    const promise = fetchBoxesRange(start, end).finally(() => {
      if (inflightBoxes && inflightBoxes.promise === promise) inflightBoxes = null;
    });
    inflightBoxes = { start, end, promise };
    return promise;
  }

  async function getBoxesForFrame(frame) {
    const cached = boxesCache.get(frame);
    if (cached) return cached;
    await schedulePrefetch(frame);
    return boxesCache.get(frame) || [];
  }

  // --- Render Loop ---
  function currentFrame() {
    return Math.max(0, Math.round(v.currentTime * FPS));
  }

  function drawBoxes(boxes) {
    ctx.clearRect(0, 0, c.width, c.height);
    if (!overlayToggle.checked) return;
    if (!boxes || boxes.length === 0) return;

    const vw = v.videoWidth;
    const vh = v.videoHeight;
    if (!vw || !vh) return;
    const sx = c.width / vw;
    const sy = c.height / vh;

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'red';
    for (const b of boxes) {
      const w = b.width * sx;
      const h = b.height * sy;
      const x = b.x * sx - w / 2;
      const y = b.y * sy - h / 2;
      ctx.strokeRect(x, y, w, h);
    }

    boxesPre.textContent = `Count: ${boxes.length}\n` + JSON.stringify(boxes, null, 2);
  }

  async function tick() {
    if (v.readyState >= 2 && currentVideo) {
      const f = currentFrame();
      if (f !== lastFrame) {
        lastFrame = f;
        const cached = boxesCache.get(f);
        const boxes = cached || [];
        if (!cached) schedulePrefetch(f);

        drawBoxes(boxes);
        info.textContent = `t=${formatTime(v.currentTime)}, frame=${f}`;
      }
    }
    requestAnimationFrame(tick);
  }

  // --- Timeline Drawing ---
  function drawTimeline() {
    if (!timeline) return;
    if (!tl.width) resizeTimeline();
    const W = tl.width, H = tl.height;
    tlx.clearRect(0, 0, W, H);
    const n = timeline.length;
    if (n === 0) return;
    let maxv = 1;
    for (let i = 0; i < n; i++) maxv = Math.max(maxv, timeline[i]);
    for (let i = 0; i < n; i++) {
      const x0 = Math.floor(i * W / n);
      const x1 = Math.floor((i + 1) * W / n);
      const v = timeline[i];
      if (v <= 0) continue;
      const h = Math.floor((v / maxv) * (H - 2));
      tlx.fillRect(x0, H - h, Math.max(1, x1 - x0), h);
    }
  }

  // --- UI Update Helper ---
  function updatePlayPauseLabel() {
    playPauseBtn.textContent = v.paused ? 'Play' : 'Pause';
  }
  function updateTimeUI() {
    if (!isSeeking && Number.isFinite(v.currentTime)) {
      seek.value = String(v.currentTime);
    }
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(dur)}`;
  }

  // --- Counter & Log ---
  function resetCounters() {
    countIn = 0; countOut = 0; eventLogs = [];
    updateCounterUI(); renderLogs();
  }
  function updateCounterUI() {
    if (displayIn) displayIn.textContent = countIn;
    if (displayOut) displayOut.textContent = countOut;
  }
  function renderLogs() {
    logPreview.innerHTML = '';
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      const log = eventLogs[i];
      const timeStr = formatTime(log.rawTime);
      const div = document.createElement('div');
      div.textContent = `[${timeStr}] ${log.type}`;
      logPreview.appendChild(div);
    }
  }
  function addLog(type) {
    eventLogs.push({ rawTime: v.currentTime, type: type });
    renderLogs();
  }
  function removeLastLog(type) {
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      if (eventLogs[i].type === type) {
        eventLogs.splice(i, 1); renderLogs(); return;
      }
    }
  }

  // [수정됨] 수동 조작 시 + 버튼도 로그를 남기도록 변경
  window.manualAdjust = function (type, delta) {
    if (type === 'in') {
      if (delta > 0) {
        countIn++;
        addLog('IN'); // [추가] + 버튼 누를 때 로그 생성
      } else {
        if (countIn > 0) { countIn--; removeLastLog('IN'); }
      }
    } else { // out
      if (delta > 0) {
        countOut++;
        addLog('OUT'); // [추가] + 버튼 누를 때 로그 생성
      } else {
        if (countOut > 0) { countOut--; removeLastLog('OUT'); }
      }
    }
    updateCounterUI();
  };

  window.downloadCSV = function () {
    if (eventLogs.length === 0) { alert("No logs."); return; }
    let csv = "data:text/csv;charset=utf-8,Video Time,Real Time,Type\n";
    eventLogs.forEach(row => {
      csv += `${formatTime(row.rawTime)},${formatTime(row.rawTime + 28800)},${row.type}\n`;
    });
    csv += `\nSummary,,\nTotal IN,${countIn},\nTotal OUT,${countOut},\n`;
    const link = document.createElement("a");
    link.setAttribute("href", encodeURI(csv));
    link.setAttribute("download", currentVideo ? `log_${currentVideo}.csv` : "log.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // --- Event Listeners ---
  playPauseBtn.addEventListener('click', async () => {
    v.paused ? v.play().catch(() => { }) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('click', async () => {
    v.paused ? v.play().catch(() => { }) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('play', updatePlayPauseLabel);
  v.addEventListener('pause', updatePlayPauseLabel);
  v.addEventListener('timeupdate', updateTimeUI);
  v.addEventListener('durationchange', () => {
    if (Number.isFinite(v.duration)) seek.max = String(Math.max(0, v.duration));
    updateTimeUI();
  });
  speedSelect.addEventListener('change', () => setPlaybackRate(parseFloat(speedSelect.value)));
  seek.addEventListener('input', () => {
    isSeeking = true;
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(Number(seek.value))} / ${formatTime(dur)}`;
  });
  seek.addEventListener('change', () => {
    v.currentTime = clamp(Number(seek.value), 0, v.duration - 0.001);
    isSeeking = false; lastFrame = -1;
  });
  window.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (['input', 'select', 'textarea'].includes(tag)) return;
    if (e.code === 'Space') { e.preventDefault(); v.paused ? v.play().catch(() => { }) : v.pause(); }
    else if (e.code === 'ArrowLeft') { e.preventDefault(); moveFrame(-1); lastFrame = -1; }
    else if (e.code === 'ArrowRight') { e.preventDefault(); moveFrame(1); lastFrame = -1; }
    else if (e.key.toLowerCase() === 'n') { e.preventDefault(); jumpHit('next'); }
    else if (e.key.toLowerCase() === 'p') { e.preventDefault(); jumpHit('prev'); }
    else if (e.key.toLowerCase() === 'i') { e.preventDefault(); window.manualAdjust('in', 1); updateCounterUI(); } // Keydown에서는 addLog 중복 방지 (manualAdjust가 호출하므로)
    else if (e.key.toLowerCase() === 'o') { e.preventDefault(); window.manualAdjust('out', 1); updateCounterUI(); }
  });

  // [수정됨] 키보드 단축키 핸들러 약간 수정 (중복 로그 방지)
  // 키보드로 'I'를 누르면 -> manualAdjust('in', 1)을 호출 -> 거기서 addLog('IN') 실행
  // 따라서 기존 keydown 리스너에서 직접 addLog를 호출하던 부분은 제거하거나 통합해야 합니다.
  // 위 keydown 리스너에서 이미 manualAdjust를 호출하도록 변경해두었습니다.

  tl.addEventListener('click', (e) => {
    if (!timeline || !currentVideo || !v.duration) return;
    const rect = tl.getBoundingClientRect();
    const t = clamp(Math.floor((e.clientX - rect.left) * timeline.length / rect.width), 0, timeline.length - 1) * binSec;
    v.currentTime = clamp(t, 0, v.duration - 0.01);
  });
  document.getElementById('reload').onclick = loadVideos;
  sel.onchange = () => selectVideo(sel.value);
  document.getElementById('prevF').onclick = () => moveFrame(-1);
  document.getElementById('nextF').onclick = () => moveFrame(1);
  // [수정] 스캔 로직 제거: 바로 점프
  document.getElementById('prevHit').onclick = () => jumpHit('prev');
  document.getElementById('nextHit').onclick = () => jumpHit('next');
  window.addEventListener('resize', () => { resizeCanvasToVideo(); resizeTimeline(); drawTimeline(); updateTimeUI(); });

  async function moveFrame(delta) { if (currentVideo) v.currentTime = (currentFrame() + delta) / FPS + 0.0001; }

  // [수정됨] Scanning 루프 제거하고 즉시 이동
  async function jumpHit(dir) {
    if (!currentVideo) return;

    // 단순 호출
    const r = await fetch(`api/videos/${currentVideo}/${dir}_hit?frame=${currentFrame()}`);
    if (r.ok) {
      const j = await r.json();
      if (j.frame != null) {
        v.currentTime = j.frame / FPS + 0.0001;
      } else {
        // 더 이상 히트가 없음
        alert("No more hits."); // 필요하면 주석 해제
      }
    }
  }

  loadVideos();
  tick();
</script>